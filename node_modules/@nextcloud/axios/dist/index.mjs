import { getRequestToken, onRequestTokenUpdate } from "@nextcloud/auth";
import Axios, { isAxiosError } from "axios";
import { isAxiosError as isAxiosError2, isCancel } from "axios";
import { generateUrl } from "@nextcloud/router";
/*!
 * SPDX-License-Identifier: GPL-3.0-or-later
 * SPDX-FileCopyrightText: 2025 Nextcloud GmbH and Nextcloud contributors
 */
const client = Axios.create({
  headers: {
    requesttoken: getRequestToken() ?? "",
    "X-Requested-With": "XMLHttpRequest"
  }
});
onRequestTokenUpdate((token) => {
  client.defaults.headers.requesttoken = token;
});
const cancelableClient = Object.assign(client, {
  CancelToken: Axios.CancelToken,
  isCancel: Axios.isCancel
});
const RETRY_KEY = Symbol("csrf-retry");
function onCsrfTokenError(axios) {
  return async (error) => {
    if (!isAxiosError(error)) {
      throw error;
    }
    const { config, response, request } = error;
    const responseURL = request?.responseURL;
    if (config && !config[RETRY_KEY] && response?.status === 412 && response?.data?.message === "CSRF check failed") {
      console.warn(`Request to ${responseURL} failed because of a CSRF mismatch. Fetching a new token`);
      const { data: { token } } = await axios.get(generateUrl("/csrftoken"));
      console.debug(`New request token ${token} fetched`);
      axios.defaults.headers.requesttoken = token;
      return axios({
        ...config,
        headers: {
          ...config.headers,
          requesttoken: token
        },
        [RETRY_KEY]: true
      });
    }
    throw error;
  };
}
const RETRY_DELAY_KEY = Symbol("retryDelay");
function onMaintenanceModeError(axios) {
  return async (error) => {
    if (!isAxiosError(error)) {
      throw error;
    }
    const { config, response, request } = error;
    const responseURL = request?.responseURL;
    const status = response?.status;
    const headers = response?.headers;
    let retryDelay = typeof config?.[RETRY_DELAY_KEY] === "number" ? config?.[RETRY_DELAY_KEY] : 1;
    if (status === 503 && headers?.["x-nextcloud-maintenance-mode"] === "1" && config?.retryIfMaintenanceMode) {
      retryDelay *= 2;
      if (retryDelay > 32) {
        console.error("Retry delay exceeded one minute, giving up.", { responseURL });
        throw error;
      }
      console.warn(`Request to ${responseURL} failed because of maintenance mode. Retrying in ${retryDelay}s`);
      await new Promise((resolve) => {
        setTimeout(resolve, retryDelay * 1e3);
      });
      return axios({
        ...config,
        [RETRY_DELAY_KEY]: retryDelay
      });
    }
    throw error;
  };
}
async function onNotLoggedInError(error) {
  if (isAxiosError(error)) {
    const { config, response, request } = error;
    const responseURL = request?.responseURL;
    const status = response?.status;
    if (status === 401 && response?.data?.message === "Current user is not logged in" && config?.reloadExpiredSession && window?.location) {
      console.error(`Request to ${responseURL} failed because the user session expired. Reloading the page â€¦`);
      window.location.reload();
    }
  }
  throw error;
}
cancelableClient.interceptors.response.use((r) => r, onCsrfTokenError(cancelableClient));
cancelableClient.interceptors.response.use((r) => r, onMaintenanceModeError(cancelableClient));
cancelableClient.interceptors.response.use((r) => r, onNotLoggedInError);
export {
  cancelableClient as default,
  isAxiosError2 as isAxiosError,
  isCancel
};
//# sourceMappingURL=index.mjs.map
