"use strict";
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const auth = require("@nextcloud/auth");
const Axios = require("axios");
const router = require("@nextcloud/router");
const _interopDefault = (e) => e && e.__esModule ? e : { default: e };
const Axios__default = /* @__PURE__ */ _interopDefault(Axios);
/*!
 * SPDX-License-Identifier: GPL-3.0-or-later
 * SPDX-FileCopyrightText: 2025 Nextcloud GmbH and Nextcloud contributors
 */
const client = Axios__default.default.create({
  headers: {
    requesttoken: auth.getRequestToken() ?? "",
    "X-Requested-With": "XMLHttpRequest"
  }
});
auth.onRequestTokenUpdate((token) => {
  client.defaults.headers.requesttoken = token;
});
const cancelableClient = Object.assign(client, {
  CancelToken: Axios__default.default.CancelToken,
  isCancel: Axios__default.default.isCancel
});
const RETRY_KEY = Symbol("csrf-retry");
function onCsrfTokenError(axios) {
  return async (error) => {
    if (!Axios.isAxiosError(error)) {
      throw error;
    }
    const { config, response, request } = error;
    const responseURL = request?.responseURL;
    if (config && !config[RETRY_KEY] && response?.status === 412 && response?.data?.message === "CSRF check failed") {
      console.warn(`Request to ${responseURL} failed because of a CSRF mismatch. Fetching a new token`);
      const { data: { token } } = await axios.get(router.generateUrl("/csrftoken"));
      console.debug(`New request token ${token} fetched`);
      axios.defaults.headers.requesttoken = token;
      return axios({
        ...config,
        headers: {
          ...config.headers,
          requesttoken: token
        },
        [RETRY_KEY]: true
      });
    }
    throw error;
  };
}
const RETRY_DELAY_KEY = Symbol("retryDelay");
function onMaintenanceModeError(axios) {
  return async (error) => {
    if (!Axios.isAxiosError(error)) {
      throw error;
    }
    const { config, response, request } = error;
    const responseURL = request?.responseURL;
    const status = response?.status;
    const headers = response?.headers;
    let retryDelay = typeof config?.[RETRY_DELAY_KEY] === "number" ? config?.[RETRY_DELAY_KEY] : 1;
    if (status === 503 && headers?.["x-nextcloud-maintenance-mode"] === "1" && config?.retryIfMaintenanceMode) {
      retryDelay *= 2;
      if (retryDelay > 32) {
        console.error("Retry delay exceeded one minute, giving up.", { responseURL });
        throw error;
      }
      console.warn(`Request to ${responseURL} failed because of maintenance mode. Retrying in ${retryDelay}s`);
      await new Promise((resolve) => {
        setTimeout(resolve, retryDelay * 1e3);
      });
      return axios({
        ...config,
        [RETRY_DELAY_KEY]: retryDelay
      });
    }
    throw error;
  };
}
async function onNotLoggedInError(error) {
  if (Axios.isAxiosError(error)) {
    const { config, response, request } = error;
    const responseURL = request?.responseURL;
    const status = response?.status;
    if (status === 401 && response?.data?.message === "Current user is not logged in" && config?.reloadExpiredSession && window?.location) {
      console.error(`Request to ${responseURL} failed because the user session expired. Reloading the page â€¦`);
      window.location.reload();
    }
  }
  throw error;
}
cancelableClient.interceptors.response.use((r) => r, onCsrfTokenError(cancelableClient));
cancelableClient.interceptors.response.use((r) => r, onMaintenanceModeError(cancelableClient));
cancelableClient.interceptors.response.use((r) => r, onNotLoggedInError);
Object.defineProperty(exports, "isAxiosError", {
  enumerable: true,
  get: () => Axios.isAxiosError
});
Object.defineProperty(exports, "isCancel", {
  enumerable: true,
  get: () => Axios.isCancel
});
exports.default = cancelableClient;
//# sourceMappingURL=index.cjs.map
