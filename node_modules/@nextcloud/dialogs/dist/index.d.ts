/// <reference types="@nextcloud/typings" />

import { AsyncComponent } from 'vue';
import type { Component } from 'vue';
import type { DefaultComputed } from 'vue/types/options.js';
import type { DefaultData } from 'vue/types/options.js';
import type { DefaultMethods } from 'vue/types/options.js';
import type { Node as Node_2 } from '@nextcloud/files';
import { PropType } from 'vue';
import { default as Toastify_2 } from 'toastify-js';

export declare class FilePicker {
    private title;
    private multiSelect;
    private mimeTypeFiler;
    private modal;
    private type;
    private directoriesAllowed;
    private buttons?;
    private path?;
    private filter?;
    constructor(title: string, multiSelect: boolean, mimeTypeFilter: string[], modal: boolean, type: FilePickerType, directoriesAllowed: boolean, path?: string, filter?: Nextcloud.v24.FilePickerFilter, buttons?: FilePickerButton[]);
    pick(): Promise<string | string[]>;
}

export declare class FilePickerBuilder {
    private title;
    private multiSelect;
    private mimeTypeFiler;
    private modal;
    private type;
    private directoriesAllowed;
    private path?;
    private filter?;
    private buttons;
    constructor(title: string);
    setMultiSelect(ms: boolean): FilePickerBuilder;
    addMimeTypeFilter(filter: string): FilePickerBuilder;
    setMimeTypeFilter(filter: string[]): FilePickerBuilder;
    addButton(button: FilePickerButton): FilePickerBuilder;
    /**
     * @param modal no function
     * @deprecated Does not have any effect as the dialog is always modal
     */
    setModal(modal: boolean): FilePickerBuilder;
    setType(type: FilePickerType): FilePickerBuilder;
    allowDirectories(allow?: boolean): FilePickerBuilder;
    startAt(path: string): FilePickerBuilder;
    setFilter(filter: Nextcloud.v24.FilePickerFilter): FilePickerBuilder;
    build(): FilePicker;
}

declare interface FilePickerButton {
    text: string;
    type?: 'primary' | 'secondary';
    /** Passed on the callback as second argument */
    id: number;
}

export declare enum FilePickerType {
    Choose = 1,
    Move = 2,
    Copy = 3,
    CopyMove = 4,
    Custom = 5
}

/**
 * FilePicker Vue component (implemented as async component)
 * @example
 * ```vue
 * <template>
 *   <FilePicker name="Select a file" :buttons="buttons" />
 * </template>
 * <script setup lang="ts">
 *   import { FilePickerVue as FilePicker, type IFilePickerButton } from '@nextcloud/dialogs'
 *   const buttons: IFilePickerButton[] = [{
 *     label: 'Pick',
 *     callback: (nodes) => console.log('Picked', nodes)
 *   }]
 * </script>
 */
export declare const FilePickerVue: AsyncComponent<DefaultData<never>, DefaultMethods<never>, DefaultComputed, {
    name: {
        type: PropType<string>;
        required: true;
    };
    path: {
        type: PropType<string>;
        default: string;
    };
    container: {
        type: PropType<string>;
        default: string;
    };
    buttons: {
        type: PropType<IFilePickerButtonFactory | IFilePickerButton[]>;
        required: true;
    };
    allowPickDirectory: {
        type: PropType<boolean>;
        default: boolean;
    };
    multiselect: {
        type: PropType<boolean>;
        default: boolean;
    };
    filterFn: {
        type: PropType<IFilePickerFilter>;
        default: undefined;
    };
    mimetypeFilter: {
        type: PropType<string[]>;
        default: () => never[];
    };
}>;

/**
 *
 * @param title Title of the file picker
 */
export declare function getFilePickerBuilder(title: string): FilePickerBuilder;

declare interface IDialogButton {
    label: string;
    /** Callback on button click */
    callback: () => void;
    /**
     * Optional Icon for the button
     * Can be a Vue component, async Vue component, or SVG
     */
    icon?: Component | AsyncComponent | string;
    /**
     * Button type
     * @see https://nextcloud-vue-components.netlify.app/#/Components/NcButton
     */
    type?: 'primary' | 'secondary' | 'error' | 'warning' | 'success';
}

export declare interface IFilePickerButton extends Omit<IDialogButton, 'callback'> {
    callback: (nodes: Node_2[]) => void;
}

declare type IFilePickerButtonFactory = (selectedNodes: Node_2[], currentPath: string, currentView: string) => IFilePickerButton[];

/**
 * Type of filter functions to filter the FilePicker's file list
 */
declare type IFilePickerFilter = (node: Node_2) => boolean;

/**
 * Show a toast message with error styling
 *
 * @param text Message to be shown in the toast, any HTML is removed by default
 * @param options
 */
export declare function showError(text: string, options?: ToastOptions): Toast;

/**
 * Show a toast message with info styling
 *
 * @param text Message to be shown in the toast, any HTML is removed by default
 * @param options
 */
export declare function showInfo(text: string, options?: ToastOptions): Toast;

/**
 * Show a toast message
 *
 * @param data Message to be shown in the toast, any HTML is removed by default
 * @param options
 */
export declare function showMessage(data: string | Node, options?: ToastOptions): Toast;

/**
 * Show a toast message with success styling
 *
 * @param text Message to be shown in the toast, any HTML is removed by default
 * @param options
 */
export declare function showSuccess(text: string, options?: ToastOptions): Toast;

/**
 * Show a toast message with undo styling
 *
 * @param text Message to be shown in the toast, any HTML is removed by default
 * @param onUndo Function that is called when the undo button is clicked
 * @param options
 */
export declare function showUndo(text: string, onUndo: (e: MouseEvent) => void, options?: ToastOptions): Toast;

/**
 * Show a toast message with warning styling
 *
 * @param text Message to be shown in the toast, any HTML is removed by default
 * @param options
 */
export declare function showWarning(text: string, options?: ToastOptions): Toast;

/**
 * Helper to spawn a Vue dialog without having to mount it from a component
 *
 * @param dialog The dialog component to spawn
 * @param props Properties to pass to the dialog
 * @param onClose Callback when the dialog is closed
 */
export declare const spawnDialog: (dialog: Component | AsyncComponent, props: any, onClose?: (...rest: unknown[]) => void) => void;

/**
 * Type of a toast
 * @see https://apvarun.github.io/toastify-js/
 * @notExported
 */
declare type Toast = ReturnType<typeof Toastify_2>;

/** @deprecated Use ToastAriaLive.ASSERTIVE */
export declare const TOAST_ARIA_LIVE_ASSERTIVE = "assertive";

/** @deprecated Use ToastAriaLive.OFF */
export declare const TOAST_ARIA_LIVE_OFF = "off";

/** @deprecated Use ToastAriaLive.POLITE */
export declare const TOAST_ARIA_LIVE_POLITE = "polite";

/** Default timeout in ms of toasts */
export declare const TOAST_DEFAULT_TIMEOUT = 7000;

/** Timeout value to show a toast permanently */
export declare const TOAST_PERMANENT_TIMEOUT = -1;

/** Timeout in ms of a undo toast */
export declare const TOAST_UNDO_TIMEOUT = 10000;

export declare enum ToastAriaLive {
    OFF = "off",
    POLITE = "polite",
    ASSERTIVE = "assertive"
}

export declare interface ToastOptions {
    /**
     * Defines the timeout in milliseconds after which the toast is closed. Set to -1 to have a persistent toast.
     */
    timeout?: number;
    /**
     * Set to true to allow HTML content inside of the toast text
     * @default false
     */
    isHTML?: boolean;
    /**
     * Set a type of {ToastType} to style the modal
     */
    type?: ToastType;
    /**
     * Provide a function that is called after the toast is removed
     */
    onRemove?: () => void;
    /**
     * Provide a function that is called when the toast is clicked
     */
    onClick?: () => void;
    /**
     * Make the toast closable
     */
    close?: boolean;
    /**
     * Specify the element to attach the toast element to (for testing)
     */
    selector?: string;
    /**
     * Whether the messages should be announced to screen readers.
     * See the following docs for an explanation when to use which:
     * https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions
     *
     * By default, errors are announced assertive and other messages "polite".
     */
    ariaLive?: ToastAriaLive;
}

/**
 * Enum of available Toast types
 */
export declare enum ToastType {
    ERROR = "toast-error",
    WARNING = "toast-warning",
    INFO = "toast-info",
    SUCCESS = "toast-success",
    PERMANENT = "toast-error",
    UNDO = "toast-undo"
}

export { }
